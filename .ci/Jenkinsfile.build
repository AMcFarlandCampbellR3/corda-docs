#!groovy
def DOCKER_REPOSITORY = "docsite.software.r3.com"
def GITHUB_NOTIFY_CONTEXT = 'Docsite Build & Deploy 2 Stage'
def DEPLOYMENT_CREDENTIALS = 'docsite-staging'
def ARTIFACTORY_BUILD_NAME = 'Docsite Docker image'

def MAKE_PARAMS = [
    'PROD_IMAGE="${IMAGE}"',         // do not change the quotes! Variable is for Linux Shell!!
    'PROD_IMAGE_TAG="${IMAGE_TAG}"', // do not change the quotes! Variable is for Linux Shell!!
]

def MAKE_BUILD_TARGETS = [
    'prod-docker-image',
]

pipeline {
    agent { label "basic" }

    parameters {
        booleanParam defaultValue: false, description: 'Check it to force publishing Docsite Docker image regardless of the branch it is built for', name: 'FORCE_PUBLISH'
    }

    environment {
        IMAGE_TAG="${env.GIT_COMMIT[0..5]}"
        IMAGE="${DOCKER_REPOSITORY}/corda-docs-nginx"
    }

    options {
        timestamps()
        timeout(time: 30, unit: 'MINUTES')
        disableConcurrentBuilds() // this makes killAllExistingBuildsForJob always do nothing
        buildDiscarder(logRotator(daysToKeepStr: '7', artifactDaysToKeepStr: '7'))
        ansiColor('xterm')
    }

    stages {
        stage('Build Docker image') {
            steps {
                step([$class: 'GitHubCommitStatusSetter',
                      contextSource: [$class: 'ManuallyEnteredCommitContextSource', context: GITHUB_NOTIFY_CONTEXT],
                      reposSource: [$class: 'ManuallyEnteredRepositorySource', url: env.GIT_URL]
                ])
                sh """
                    make ${MAKE_PARAMS.join(' ')} ${MAKE_BUILD_TARGETS.join(' ')}
                """
		        sh 'docker images'
            }
        }
        stage('Publish Docker image to Registry') {
            when {
                anyOf {
                    branch 'master'
                    expression { params.FORCE_PUBLISH }
                }
            }
            steps {
                script {
                    docker.image("${env.IMAGE}:${env.IMAGE_TAG}").tag('latest')
                }

                echo "Creating Artifactory server"
                rtServer (
                    id: 'R3-Artifactory',
                    url: 'https://software.r3.com/artifactory',
                    credentialsId: 'docsite-publisher'
                )
                echo "Pushing '${env.IMAGE}:${env.IMAGE_TAG}' image to Artifactory Docker registry"
                rtDockerPush (
                    serverId: 'R3-Artifactory',
                    image: "${env.IMAGE}:${env.IMAGE_TAG}",
                    targetRepo: 'docsite-local',
                    buildName: ARTIFACTORY_BUILD_NAME
                )
                echo "Pushing '${env.IMAGE}:${env.IMAGE_TAG}' image to Artifactory Docker registry as 'latest'"
                rtDockerPush (
                    serverId: 'R3-Artifactory',
                    image: "${env.IMAGE}:latest",
                    targetRepo: 'docsite-local',
                    buildName: ARTIFACTORY_BUILD_NAME
                )
                echo 'Publishing build info to Artifactory server'
                rtPublishBuildInfo (
                    serverId: 'R3-Artifactory',
                    buildName: ARTIFACTORY_BUILD_NAME
                )
            }
        }
        stage('Deploy Docker image to staging') {
            when {
                anyOf {
                    branch 'master'
                    expression { params.FORCE_PUBLISH }
                }
            }
            steps {
                sshagent([DEPLOYMENT_CREDENTIALS]) {
                    sh "ssh -F /dev/null -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null docsite@docs-staging.corda.net update-docsite"
                }
            }
        }
    }

    post {
        always {
                step([$class: 'GitHubCommitStatusSetter',
                      contextSource: [$class: 'ManuallyEnteredCommitContextSource', context: GITHUB_NOTIFY_CONTEXT],
                      reposSource: [$class: 'ManuallyEnteredRepositorySource', url: env.GIT_URL]
                ])
        }
        cleanup {
            deleteDir() /* clean up our workspace */
        }
    }
}
